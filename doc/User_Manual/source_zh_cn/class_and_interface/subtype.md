# 子类型关系

与其他面向对象语言一样，仓颉语言提供子类型关系和子类型多态。举例说明（不限于下述用例）：

- 假设函数的形参是类型 `T`，则函数调用时传入的参数的实际类型既可以是 `T` 也可以是 `T` 的子类型（严格地说，`T` 的子类型已经包括 `T` 自身，下同）。
- 假设赋值表达式 `=` 左侧的变量的类型是 `T`，则 `=` 右侧的表达式的实际类型既可以是 `T` 也可以是 `T` 的子类型。
- 假设函数定义中用户标注的返回类型是 `T`，则函数体的类型（以及函数体内所有 `return` 表达式的类型）既可以是 `T` 也可以是 `T` 的子类型。

下文将说明两个类型为子类型关系的几种情况。

## 继承 class 带来的子类型关系

继承 class 后，子类即为父类的子类型。如下代码中， `Sub` 即为 `Super` 的子类型。

<!-- compile -->

```cangjie
open class Super {}
class Sub <: Super {}
```

## 实现接口带来的子类型关系

实现接口（含扩展实现）后，实现接口的类型即为接口的子类型。如下代码中，`I3` 是 `I1` 和 `I2` 的子类型， `C` 是 `I1` 的子类型， `Int64` 是 `I2` 的子类型：

<!-- compile -->

```cangjie
interface I1 {}
interface I2 {}

interface I3 <: I1 & I2 {}

class C <: I1 {}

extend Int64 <: I2 {}
```

## 元组类型的子类型关系

仓颉语言中的元组类型也有子类型关系。直观的，如果一个元组 `t1` 的每个元素的类型都是另一个元组 `t2` 的对应位置元素类型的子类型，那么元组 `t1` 的类型也是元组 `t2` 的类型的子类型。例如下面的代码中，由于 `C2 <: C1` 和 `C4 <: C3`，因此也有 `(C2, C4) <: (C1, C3)` 以及 `(C4, C2) <: (C3, C1)`。

<!-- compile -->

```cangjie
open class C1 {}
class C2 <: C1 {}

open class C3 {}
class C4 <: C3 {}

let t1: (C1, C3) = (C2(), C4()) // OK
let t2: (C3, C1) = (C4(), C2()) // OK
```

## 函数类型的子类型关系

仓颉语言中，函数是一等公民，而函数类型亦有子类型关系：给定两个函数类型 `(U1) -> S2` 和 `(U2) -> S1`，如果存在 `(U1) -> S2` 是 `(U2) -> S1`的子类型，当且仅当 `U2` 是 `U1` 的子类型，且 `S2` 是 `S1` 的子类型（注意顺序）。例如下面的代码定义了两个函数 `f : (U1) -> S2` 和 `g : (U2) -> S1`，且 `f` 的类型是 `g` 的类型的子类型。由于 `f` 的类型是 `g` 的子类型，所以代码中使用到 `g` 的地方都可以换为 `f`。

<!-- compile -->

```cangjie
open class U1 {}
class U2 <: U1 {}

open class S1 {}
class S2 <: S1 {}


func f(a: U1): S2 { S2() }
func g(a: U2): S1 { S1() }

func call1() {
    g(U2()) // OK
    f(U2()) // OK
}

func h(lam: (U2) -> S1): S1 {
    lam(U2())
}

func call2() {
    h(g) // OK
    h(f) // OK
}
```

对于上面的规则，`S2 <: S1` 部分很好理解：函数调用产生的结果数据会被后续程序使用，函数 `g` 可以产生 `S1` 类型的结果数据，函数 `f` 可以产生 `S2` 类型的结果，而 `g` 产生的结果数据应当能被 `f` 产生的结果数据替代，因此要求 `S2 <: S1`。

对于 `U2 <: U1` 的部分，可以这样理解：在函数调用产生结果前，它本身应当能够被调用，函数调用的实参类型固定不变，同时形参类型要求更宽松时，依然可以被调用，而形参类型要求更严格时可能无法被调用——例如给定上述代码中的定义 `g(U2())` 可以被换为 `f(U2())`，正是因为实参类型 `U2` 的要求更严格于形参类型 `U1`。

## 永远成立的子类型关系

仓颉语言中，有些预设的子类型关系是永远成立的：

- 一个类型 `T` 永远是自身的子类型，即 `T <: T`。
- `Nothing` 类型永远是其他任意类型 `T` 的子类型，即 `Nothing <: T`。
- 任意类型 `T` 都是 `Any` 类型的子类型，即 `T <: Any`。
- 任意 `class` 定义的类型都是 `Object` 的子类型，即如果有 `class C {}`，则 `C <: Object`。

## 传递性带来的子类型关系

子类型关系具有传递性。如下代码中，虽然只描述了 `I2 <: I1`、`C <: I2` 以及 `Bool <: I2`，但根据子类型的传递性，也隐式存在 `C <: I1` 以及 `Bool <: I1` 这两个子类型关系。

<!-- compile -->

```cangjie
interface I1 {}
interface I2 <: I1 {}

class C <: I2 {}

extend Bool <: I2 {}
```

## 泛型类型的子类型关系

泛型类型间也有子类型关系，详见[泛型类型的子类型关系](../generic/generic_subtype.md)。
