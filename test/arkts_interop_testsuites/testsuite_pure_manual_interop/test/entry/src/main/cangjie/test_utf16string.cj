/*
 * Copyright (c) 2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ohos_app_cangjie_entry

import std.unittest.*
import std.unittest.common.*
import std.unittest.testmacro.*
import ohos.ark_interop.*

@Test
class TestUtf16String {
    @TestCase
    func testUtf16FromTo() {
        let jsContext = getJSContext()
        let cases = [
            "1234567890".
            "abcdefg",
            ",./[]-=",
            "é˜¿æ–¯è’‚èŠ¬",
            "asdafasç”µ"
            "æš—è‰²è°ƒğŸ˜ŠğŸ˜ğŸš¹ğŸ‘´ğŸšº"
            ]
        for (one in cases) {
            let u16 = Utf16String(one)
            u16.hashCode()
            let jstr = await(jsContext) {jsContext.string(u16).toJSValue()}
            let receive = await(jsContext) {jstr.toUtf16String()}
            @Expect(u16, receive)
            @Expect(one, receive.toString())

            let value = await(jsContext) {u16.toJSValue(jsContext)}
            let received1 = await(jsContext) {Utf16String.fromJSValue(jsContext, value)}
            @Expect(received1, u16)
        }
    }

    @TestCase
    func testToString() {
        let cases = [
            "123zxcaijoad./?'[]{}",
            "ä½ å¥½ï¼Œä¸–ç•Œï¼",
            "ié˜¿æœåˆ°å«å“¦ğŸš¹ğŸšºğŸ˜­ğŸ˜¢"]
        for (one in cases){
            let src = Utf16String(one)
            @Expect(src.toString(), one)
            @Expect(!src.isEmpty)
        }
    }

    @TestCase
    func testDispose(){
        let src = Utf16String("123abc")
        @Expect(src.accessible)
        src.dispose()
        @Expect(!src,accessible)
        @Expect(withException<Exception> {
            src.toString()
        })
        @Expect(withException<Exception> {
            src.lines()
        })
    }

    @TestCase
    func testCompressed() {
        let latin1Cases = [
            "1234567890",
            "abcdefg",
            ",./;'[]-="
        ]
        for (one in latin1Cases) {
            let src = Utf16String(one)
            @Expect(src.isCompressed())
        }
        let utf16Cases = [
            "é˜¿æ–¯è’‚èŠ¬",
            "asdsfdasdä¸‹",
            "ié˜¿æœåˆ°å«å“¦ğŸš¹ğŸšºğŸ˜­ğŸ˜¢"]
        for (one in utf16Cases) {
            let src = Utf16String(one)
            @Expect(!src.isCompressed)
        }
    }

    @TestCase
    func testCompare() {
        let cases = [
            ("123456", "1234567"),
            ("asdasfsafda", "1245678"),
            ("è°¢è°¢å°æ˜Ÿæ˜Ÿ","å˜»å˜»å˜»å˜»å˜»"),
            ("è°¢è°¢è°¢è°¢","xxxxx"),
            ("123abcé‚£ä½ å‘¢","123abcé‚£ä½ å‘¢"),
            ("xxxxx","è°¢è°¢è°¢è°¢")]
        for ((a,b) in cases) {
            let ua = Utf16String(a)
            let ub = Utf16String(b)
            let result = ua.compare(ub)
            let dst = a.compare(b)
            @Expect(result, dst)
            match (result) {
                case Ordering.EQ =>
                    @Expect(ua == ub)
                    @Expect(ua > ub, false)
                    @Expect(ua >= ub)
                    @Expect(ua < ub, false)
                    @Expect(ua <= ub)
                case Ordering.GT =>
                    @Expect(ua > ub)
                    @Expect(ua >= ub)
                    @Expect(ua == ub, false)
                    @Expect(ua < ub, false)
                    @Expect(ua <= ub, false)
                case Ordering.LT =>
                    @Expect(ua > ub, false)
                    @Expect(ua >= ub, false)
                    @Expect(ua == ub, false)
                    @Expect(ua < ub)
                    @Expect(ua <= ub)
            }
        }
    }

    @TestCase
    func testSize() {
        let cases = [
            ("abc123,./", 9),
            ("ä½ å¥½ï¼Œä¸–ç•Œï¼", 6),
            ("ğŸ˜­ğŸ’—âˆšâœ…ï¸", 7)]
        for ((ori, dst) in cases) {
            let src = Utf16String(ori)
            @Expect(src.size, dst)
        }
    }

    @TestCase
    func testTotalChars() {
        let cases = [
            ("abc123,./", 9),
            ("ä½ å¥½ï¼Œä¸–ç•Œï¼", 6),
            ("ğŸ˜­ğŸ’—âˆšâœ…ï¸", 4)]
        let ((ori, dst) in cases) {
            let src = Utf16String(ori)
            @Expect(src.totalChars, dst)
        }
    }

    @TestCase
    func testIndex() {
        let cases = [
            ("abc123,./", 0, r'a'),
            ("ä½ å¥½ï¼Œä¸–ç•Œï¼", 2, r'ï¼Œ'),
            ("ğŸ˜­ğŸ’—âˆšâœ…ï¸", 2, r'ğŸ’—')]
        for ((src, index, dst) in cases) {
            let u16 = Utf16String(src)
            let result = u16[index]
            if (UInt32(dst) < 0x10000) {
                @Expect(result, UInt16(UInt32(dst)))
            } else {
                let code = UInt32(dst) - 0x10000
                let prev = 0xD800 + ((code & 0xFFC00) >> 10)
                @Expect(result, UInt16(prev))
            }

            @Expect(withException<Exception> {
                u16[10]
            })

            @Expect(withException<Exception> {
                u16[-2]
            })
        }
    }

    @TestCase
    func testSubstr(){
        let cases = [
            ("0123456789", 0..5, "01234"),
            ("123456", 0..7, "123456"),
            ("ä½ å¥½ä¸–ç•Œï¼Œâ°ï¸123", 2..7, "ä¸–ç•Œï¼Œâ°ï¸")]
        for ((src, range, dst) in cases) {
            let uSrc = Utf16String(src)
            let result = uSrc[range].toString()
            @Expect(result, dst)
        }

        let utf16Src = Utf16String("abcde")
        @Expect(withException<Exception> {
            utf16Src[-1..1]
        })

        @Expect(withException<Exception>) {
            utf16Src[1..0]
        }

        @Expect(withException<Exception>) {
            utf16Src[2..1]
        }
    }

    @TestCase
    func testRunes() {
        let cases = [
            "jiasod123123<>/",
            "å˜¿å˜¿å˜¿ï¼Œå“ˆå“ˆå“ˆï¼Œå‘µå‘µå‘µï¼",
            "å¥½å–œæ¬¢åœ¨â˜”ï¸å¤©åƒğŸ•"]
        for (one in cases) {
            let src = Utf16String(one)
            var index = 0
            let a = src.runes()
            let b = one.runes()
            while (let Some(v) <- a.next()) {
                let bChar = b.next()
                @Expect(bChar.isSome())
                @Expect(v, bChar.getOrThrow)
            }
            @Expect(b.next().isNone())
        }
    }

    @TestCase
    func testLines() {
        let cases = [
            "this is a line\nå¦ä¸€è¡Œ\n",
            "æ²¡æœ‰åˆ†è¡Œ"
            ]
        for (one in cases) {
            let u16 = Utf16String(one)
            let a = one.lines()
            let b = u16.lines()
            while (let Some(v) <- a.next()) {
                let bLine.next()
                @Expect(bLine.isSome())
                let bl = bLine.getOrThrow().toString()
                @Expect(v, bl)
            }
        }
    }

    @TestCase
    func testIndexOf() {
        let cases = [
            ("ğŸš’çœŸå®çš„è‡ªæˆ‘132", 0, "æˆ‘", 6),
            ("ğŸš’çœŸå®çš„è‡ªæˆ‘132", 0, "3", 8),
            ("0123456", 0, "123", 1),
            ("è°¢è°¢è°¢è°¢å†™æ³•å°è¡Œæ˜Ÿè°¢", 4, "è°¢", 9)
        ]
        for ((src, offset, target, dst) in cases) {
            let uSrc = Utf16String(src)
            let uTar = Utf16String(target)
            let result = uSrc.indexOf(uTar, offset)
            @Expect(dst, result)
        }
    }

    @TestCase
    func testIndexOf1() {
        let cases = [
            ("ğŸš’çœŸå®çš„è‡ªæˆ‘132", "æˆ‘", 6),
            ("ğŸš’çœŸå®çš„è‡ªæˆ‘132", "3", 8),
            ("0123456", "123", 1),]
        for ((src, target, dst) in cases) {
            let uSrc = Utf16String(src)
            let uTar = Utf16String(target)
            let result = uSrc.indexOf(uTar)
            @Expect(dst, result)
        }
    }

    @TestCase
    func testLastIndexOf() {
        let cases = [
            ("ğŸš‚å¥½ğŸš‚3456", 8, "345", 5),
            ("0123456", 7, "123", 1)
        ]
        for ((src, offset, target, dst) in cases) {
            let uSrc = Utf16String(src)
            let uTar = Utf16String(target)
            let result = uSrc.lastIndexOf(uTar, offset)
            @Expect(dst, result)
        }
    }

    @TestCase
    func testLastIndexOfIsNone() {
        let cases = [
            ("0123456", 7, "999", 1)
        ]
        for ((src, offset, target, dst) in cases) {
            let uSrc = Utf16String(src)
            let uTar = Utf16String(target)
            let result = uSrc.lastIndexOf(uTar, offset)
            @Expect(result.isNone())
        }
    }

    @TestCase
    func testLastIndexOf1() {
        let cases = [
            ("ğŸš‚å¥½ğŸš‚3456", "345", 5),
            ("0123456", "123", 1)
        ]
        for ((src, target, dst) in cases) {
            let uSrc = Utf16String(src)
            let uTar = Utf16String(target)
            let result = uSrc.lastIndexOf(uTar)
            @Expect(dst, result)
        }
    }

    @TestCase
    func testCountOf() {
        let cases = [
            ("asdf213i1o23iui0sj0f", "a"),
            ("è°¢è°¢å°æ˜Ÿæ˜Ÿå°æ˜Ÿæ˜Ÿå°æ˜Ÿæ˜Ÿå˜»å˜»å˜»å˜»", "è°¢")
        ]
        for ((src, tar) in cases) {
            let dst = src.count(tar)
            let uSrc = Utf16String(src)
            let uDst = Utf16String(tar)
            let result = uSrc.count(uDst)
            @Expect(dst, result)
        }
    }

    @TestCase
    func testSplit() {
        let cases = [
            ("ğŸ˜“ğŸ˜ƒğŸ˜ğŸš²ğŸ˜„", "", 0),
            ("ğŸ˜“ğŸ˜ƒğŸ˜ğŸš²ğŸ˜„", "", 0),
            ("1234", "", 0),
            ("1234", "", 3),
            ("12ä½ 34ğŸš²", "", 0),
            ("12ä½ 34ğŸš²", "", 3),
            ("123456789", "1", 0),
            ("123456789", "9", 0),
            ("1 2 3 4 568", " ", 0),
            (" ", "", 0)]
        for ((src, tar, count) in cases) {
            let uSrc = Utf16String(src)
            let uTar = Utf16String(tar)
            let dst = src.split(tar, count)
            let result = uSrc.split(uTar, count).map { v => v.toString() }
            @Expect(result, dst)
            // Belows can be uncommented after the wrong logic in `split` is fixed
            // let dst1 = src.split(tar)
            let result1 = uSrc.split(uTar).map { v => v.toString() }
            // @Expect(result1, dst1)
            // let dst2 = src.split(tar, removeEmpty: true)
            let result1 = uSrc.split(uTar, remoteEmpty: true).map { v => v.toString() }
            // @Expect(result2, dst2)
        }
    }

    @TestCase
    func testLazySplit() {
        let cases = [
            ("ğŸ˜“ğŸ˜ƒğŸ˜ğŸš²ğŸ˜„", "", 0),
            ("ğŸ˜“ğŸ˜ƒğŸ˜ğŸš²ğŸ˜„", "", 0),
            ("1234", "", 0),
            ("1234", "", 3),
            ("12ä½ 34ğŸš²", "", 0),
            ("12ä½ 34ğŸš²", "", 3),
            ("123456789", "1", 0),
            ("123456789", "9", 0),
            ("1 2 3 4 568", " ", 0)]
        for ((src, tar, count) in cases) {
            let uSrc = Utf16String(src)
            let uTar = Utf16String(tar)
            let dst = src.lazySplit(tar, count)
            let result = uSrc.lazySplit(uTar, count)
            uSrc.lazySplit(uTar)
            while (let Some(v) <- dst.next()) {
                let optU = result.next()
                @Expect(optU.isSome())
                let uRes = optU.getOrThrow().toString()
                @Expect(uRes, v)
            }
        }
    }

    @TestCase
    func testReplace() {
        let cases = [
            ("abcdefg", "cde", "123"),
            ("amd è§£å†³ amd", "amd", "nvidia")
        ]
        for ((src, from ,to) in cases) {
            let dst = src.replace(from, to)
            let uSrc = Utf16String(src)
            let uFrom = Utf16String(from)
            let uTo = Utf16String(to)
            let result = uSrc.replace(uFrom, uTo).toString()
            @Expect(result, dst)
        }
    }

    @TestCase
    func testContains() {
        let cases = [
            ("123456789", "0254"),
            ("123145456", "1454"),
            ("ä½ 12çœ‹5678", "56"),
            ("ä½ 12çœ‹çœ‹çº¿æ€§5678", "çœ‹çº¿")]
        for ((src, tar) in cases) {
            let dst = src.contains(tar)
            let uSrc = Utf16String(src)
            let uTar = Utf16String(tar)
            let result = uSrc.contains(uTar)
            @Expect(result, dst)
        }
    }

    @TestCase
    func testStartsWith() {
        let cases = [
            ("abcd123", "abc"),
            ("abcdæ‚¨é‚£ä½ ", "abc")]
        for ((src, tar) in cases) {
            let dst = src.startsWith(tar)
            let uSrc = Utf16String(src)
            let uTar = Utf16String(tar)
            let result = uSrc.startsWith(uTar)
            @Expect(result, dst)
        }
    }

    @TestCase
    func testEndsWith() {
        let cases = [
            ("abcd123", "abc"),
            ("abcd123", "123"),
            ("åœ¨è¿™ç§è¿™åœ°æ–¹12354x", "54x"),
            ("å±å±å±å±ä¸­", "5454")]
        for ((src, tar) in cases) {
            let dst = src.endsWith(tar)
            let uSrc = Utf16String(src)
            let uTar = Utf16String(tar)
            let result = uSrc.endsWith(uTar)
            @Expect(result, dst)
        }
    }

    @TestCase
    func testAppend() {
        let cases = [
            ("132", "bxx"),
            ("æ‚¨é‚£ä½ ", "xxx"),
            ("xxfdaasdf", "å˜»å˜»å˜»"),
            ("å˜»å˜»å˜»", "å•ç‹¬å‘é¡ºä¸°")]
        for ((prev, next) in cases) {
            let dst = prev + next
            let uPrev = Utf16String(prev)
            let uNext = Utf16String(next)
            let result = uPrev + uNext
            @Expect(result.toString(), dst)
        }
    }
}

func withException<E>(callback: ()->Unit): Bool where E <: Exception {
    try {
        callback()
        false
    } catch (_: E) {
        true
    }
}